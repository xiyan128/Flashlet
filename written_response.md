# Written Response

### 2a

The software I developed in response to this performance task is an intelligent flashcard app, which I named Flashlet. It is built using the programming language Dart, along with Flutter, Google's multi-platform mobile app SDK. The purpose of Flashlet is to help students remember informations in a more efficient way, by providing an interface for inputing and exhibiting flashcards, recording user's study result (by gathering subjective proficiency ratings), and analyzing user's study progress (based on mathematical models) to suggest future plans. In the video, I demonstrated a sample process of how a user can create a deck (i.e. a set of cards) and study it, as well as how the software gives feedbacks; nevertheless, other features, like editing deck informations, adding and deleting cards after the deck being created, though implemented, are not shown.

### 2b

Behind this obscure app are repeated failures and endeavors. This first obstacle I faced was that there is no mature data persistent solution available to me since Flutter's fledging open source community is too feeble to provide out-of-the-box solutions in many facets. To deal with it, I looked back the naive, file based storing: For each class to be stored (e.g. `Card`), I created two additional methods – one for JSON serialization and one for deserialization – and an `id` field, accordingly. In addition, repositories maintaining ID-JSON maps and providing `get` and `write` API are implemented. Ultimately, I managed to request local-stored data to render in view components. Another difficulty is how to arm the app with "intelligence". One classic (yet often misused) approach is to employ the Leitner's spaced repetition system, but fortunately, I found that a recent study conducted by CMU has proposed a new model that can yield a better result (as tested by a large dataset). It inspired me that the rate of recalling can be approximated to a function of user's subjective difficulty rating, time, and review times. I simplified and implemented the algorithm, ending up with a fairly good result.

My **incremental developing** process started from OOD. I first outlined the layers involved: a *View* layer for dealing with UI, a *Model* layer for storing and retrieving data, and an *Middleware* layers for manipulating raw data with algorithms. Each page in the *View* layer is abstracted into a specific class, so does smaller components within pages; they are all created **incrementally**. A major **difficulty** occurs in implementing the *Model* layer – there's no mature data-persistent solution for fledging Flutter. To deal with it, I looked back to the naive, file based approach: I made each entity class (e.g. `Deck`) (de)serializable to JSON, and created `Repository` classes to handle file IO. Each entity class contains a static unit test method, and I utilized Dart Debugger to trace bugs; this process embodied **iterative programming**. Another difficulty was how to predict a user's retention. Leitner's spaced repetition system is a common yet obsolete practice; however **fortunately**, a recent study conducted by CMU inspired me that it can be approximated to a function of user's subjective difficulty rating, lag time, and review times. I implemented and, by hiring friends, tested this model, ending up with an acceptable result.

### 2c
